# 滑动窗口最大值算法思路详解

这个算法使用双端队列（Deque）来高效地找到每个滑动窗口的最大值。下面我将详细解释其核心思路和工作原理。

## 基本概念

**问题描述**：给定一个数组和一个固定大小的窗口，窗口从数组的最左端滑动到最右端，每次滑动一个位置，返回每个窗口中的最大值组成的数组。

**示例**：
输入数组：`[1, 3, -1, -3, 5, 3, 6, 7]`，窗口大小 `k=3`
输出结果：`[3, 3, 5, 5, 6, 7]`

## 算法核心思路

### 1. 使用双端队列的原因

双端队列可以在两端高效地添加和删除元素（O(1)时间复杂度），这使得它非常适合维护一个动态变化的候选最大值集合。

### 2. 队列中存储的内容

队列中存储的是**数组元素的索引**，而不是元素值本身。这是因为：
- 我们需要知道元素是否还在当前窗口内
- 通过索引可以方便地访问元素值

### 3. 队列的维护规则

队列中的元素按照从大到小的顺序排列（即队列头部是当前窗口的最大值），维护规则如下：

#### a) 移除不在窗口内的元素

```java
while (!deque.isEmpty() && deque.peek() < i - k + 1) {
    deque.poll();
}
```

- `deque.peek()` 是队列头部的索引
- `i - k + 1` 是当前窗口的起始位置
- 如果队列头部的索引小于窗口起始位置，说明该元素已不在当前窗口内，需要移除

#### b) 移除小于当前元素的元素

```java
while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
    deque.pollLast();
}
```

- 从队列尾部开始比较
- 如果队列尾部元素的值小于当前元素的值，则移除它
- 因为这些较小的元素不可能成为当前或未来窗口的最大值

#### c) 添加当前元素

```java
deque.offer(i);
```

- 将当前元素的索引加入队列尾部

### 4. 记录结果

```java
if (i >= k - 1) {
    result[ri++] = nums[deque.peek()];
}
```

- 当窗口形成后（即 `i >= k-1`）
- 队列头部元素就是当前窗口的最大值

## 示例运行过程

以输入 `[1, 3, -1, -3, 5, 3, 6, 7]`，`k=3` 为例：

| i | nums[i] | 窗口范围 | 队列内容(索引) | 最大值 | 操作说明 |
|---|--------|---------|---------------|-------|---------|
| 0 | 1      | [0]     | [0]           | -     | 初始添加 |
| 1 | 3      | [0,1]   | [1]           | -     | 移除0(1<3)，添加1 |
| 2 | -1     | [0,1,2] | [1,2]         | 3     | 添加2(-1<3)，记录nums[1]=3 |
| 3 | -3     | [1,2,3] | [1,2,3]       | 3     | 移除1(不在窗口)，添加3，记录nums[1]=3 |
| 4 | 5      | [2,3,4] | [4]           | 5     | 移除所有(都<5)，添加4，记录nums[4]=5 |
| 5 | 3      | [3,4,5] | [4,5]         | 5     | 添加5(3<5)，记录nums[4]=5 |
| 6 | 6      | [4,5,6] | [6]           | 6     | 移除所有(都<6)，添加6，记录nums[6]=6 |
| 7 | 7      | [5,6,7] | [7]           | 7     | 移除所有(都<7)，添加7，记录nums[7]=7 |

最终结果：`[3, 3, 5, 5, 6, 7]`

## 为什么这个算法高效？

1. **时间复杂度O(n)**：每个元素最多被添加和移除队列各一次
2. **空间复杂度O(k)**：队列最多存储k个元素
3. **避免了重复比较**：通过维护递减队列，确保每次都能直接获取当前窗口的最大值

这种算法比暴力解法（每个窗口都重新扫描所有元素）要高效得多，特别是当数组很大时。

## 个人问题
如何保证队列中存储的索引是递增的？

小于当前值则删除，当前值直接插入到双端队列尾部
